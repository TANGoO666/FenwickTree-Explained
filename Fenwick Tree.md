# 树状数组 Fenwick Tree
>可以高效查询数组的 前缀和 的数据结构  
>索引从 $1$ 开始

## lowbit

### lowbit(x) 的含义

`lowbit(x)` 的含义是： **十进制数** $x$ 对应的 **二进制数** 的最右边的 $1$ 所对应的 **十进制数**

举个例子:  
$(3)_{10}$ = $(0011)_{2}$，`lowbit(3) = 1`  
$(12)_{10}$ = $(1100)_{2}$，`lowbit(12) = 4`  

### lowbit(x) 的实现

在计算机中，**有符号整数**通常是以 **补码** 的形式存储的

$正整数补码 = 原码$
$负整数补码 = 反码 + 1$

所以要得到 `lowbit(x)` 十分简单，只需要 `x & -x` 就可以

这是因为， 假设 $x$ 的 二进制数 的最右边的 $1$ 处于 $位a$

默认 $x$ 是正整数， 因为 树状数组 的索引从 $1$ 开始

比 $位a$ 低的所有位（既 $位a$ 右边所有位） 都是 $0$

取反：

$位a$ 的 $1$ 取反后 变为 $0$， 比 $位a$ 低的所有位 取反后 都变成 $1$， 比 $位a$ 高的所有位照常取反

然后 $+1$：

比 $位a$ 低的所有位由于**进位**都变成 $0$， $位a$ 由于**进位**变成 $1$， 比 $位a$ 高的所有位不会被 $+1$ 影响

因此， `x & -x` 就得到了 `lowbit(x)`

举个例子：  
$(12)_{10}$ = $(1100)_{2}$ ， `lowbit(12) = 4`  
$(-12)_{10}$ 反码 = $(0011)_{2}$   
$(-12)_{10}$ 补码 = $(-12)_{10}$ 反码 + 1 = $(0100)_{2}$  
$(1100)_{2}$ `&` $(0100)_{2}$  = $(0100)_{2}$ = $(4)_{10}$  

## 查询

树状数组的索引 `[x]` 管辖着区间：`[x - lowbit(x) + 1, x]` 

查询 **原数组** `[1, x]` 区间和 流程：

1. 计算 树状数组的索引 `[x]` 管辖着区间：`[x - lowbit(x) + 1, x]` 
2. `sum += 树状数组[x]` 
3. 如果 $x - lowbit(x) + 1 > 1$  则令 $x = x - lowbit(x)$ 
4. 循环重复 1.  2.  3.  直到 $x - lowbit(x) + 1 = 1$ => 查询完毕

举个例子：

查询 **原数组** `[1, 7]` 区间和

1. `树状数组[7]` 管辖着区间：`[7 - lowbit(7) + 1, 7]` 即 `[7, 7]`
2. `sum += 树状数组[7]`
3. $7 > 1$ 则令 $x = 7 - lowbit(7) = 6$ 
4. `树状数组[6]` 管辖着区间：`[6 - lowbit(6) + 1, 6]` 即 `[5, 6]`
5. `sum += 树状数组[6]`， 此时已查询 `[5, 7]` 的区间和 
6. $5 > 1$ 则令 $x = 6 - lowbit(6) = 4$ 
7. `树状数组[4]` 管辖着区间：`[4 - lowbit(4) + 1, 4]` 即 `[1, 4]`
8. `sum += 树状数组[4]`， 此时已查询 `[1, 7]` 的区间和 
9. $1 = 1$， 查询完毕

当**原数组**长度不是很大时，可以用以下方法直观地快速判断 `树状数组[x]` 管辖的区间

![](https://i-blog.csdnimg.cn/direct/6c6a6fbfd4a140419b4ea24bb8de13c8.png)


在下标下，依次画横线，横线的长度为： $2^n$，  $n ≥ 0$ 且 $n \in \mathbb{Z}$ 

要查询 `树状数组[x]` 管辖的区间，就看所有经过该下标 **最长** 的那条横线 左端对应的下标 既为区间 **左端点**

举个例子：

`树状数组[7]` 由图可知 只有一条长度为$1$的横线经过它，这条横线的左端对应的也是下标$7$
所以 `树状数组[7]` 管辖着区间： `[7, 7]`

`树状数组[6]` 由图可知 经过下标$6$最长的那条横线长度为$2$， 该横线左端对应的是下标$5$
所以 `树状数组[6]` 管辖着区间： `[5, 6]`

`树状数组[4]` 由图可知 经过下标$4$最长的那条横线长度为$4$，该横线左端对应的是下标$1$
所以 `树状数组[4]` 管辖着区间： `[1, 4]`

这和我们上述由计算得到的结果是一致的

## 更新

由于树状数组某一个下标 管辖的区间 也许是下标本身，也许是一段区间

因此如果要对 `树状数组[x]` 进行 更新操作，就不能单纯地只修改 `树状数组[x]` 的值

更新 `树状数组[x]` 的流程：

1. 更新 `树状数组[x]` 的值
2. 令 $x = x + lowbit(x)$ 
3. 如果 $x$ 越界，则更新结束
4. 否则循环重复 1.  2. 

举个例子：

长度为$7$的树状数组，索引 $1$ ~ $7$

更新 `树状数组[2]` 的值 $+2$

1. `树状数组[2] += 2`
2. 令 $x = 2 + lowbit(2) = 4$ 
3. $4 ≤ 7$ 没有越界
4. `树状数组[4] += 2`
5. 令 $x = 4 + lowbit(4) = 8$ 
6. $8 > 7$ 越界， 则更新完毕

结合图来看，在索引 $1$ ~ $7$ 的树状数组中，要更新 `树状数组[2]` 的值，确实只需要修改 `树状数组[2]` 和 `树状数组[4]`

因为：
`树状数组[2]` 管辖区间为： `[1, 2]`
`树状数组[3]` 管辖区间为： `[3, 3]`
`树状数组[4]` 管辖区间为： `[1, 4]`，**受区间 `[1, 2]` 变更导致的影响**
`树状数组[5]` 管辖区间为： `[5, 5]`
`树状数组[6]` 管辖区间为： `[5, 6]`
`树状数组[7]` 管辖区间为： `[7, 7]`

## 完整的实现代码

```cpp
class FenwickTree {
private:
    vector<int> tree;
    int n;
    
public:
    FenwickTree(int size) : n(size), tree(size + 1, 0) {}
    
    int lowbit(int x) {
        return x & -x;
    }

    int query(int i) {
        int ans = 0;
        while(i > 0) {
            ans += tree[i];
            i -= lowbit(i);
        }
        return ans;
    }    

    int queryRange(int l, int r) {
        return query(r) - query(l - 1);
    }

    void add(int i, int val) {
        while(i <= n) {
            tree[i] += val;
            i += lowbit(i);
        }
    }
};
```

树状数组的实现代码非常简单优雅

这里提一嘴 `queryRange(int l, int r)` 的实现：

如果想查询 `[a, b]` 的区间和， 实际上就是 `[1, b]` - `[1, a - 1]` 的区间和

即使这里 `l = 1`，  `query(l - 1)` 也就是 `query(0)` 会返回 $0$，所以不会有问题

相信结合以上的说明，树状数组的实现代码是能够看懂且能够自己实现的

使用 树状数组 解决求 **逆序对** 个数是个经典问题，大家可以思考如何用 树状数组 解决这个问题

[利用树状数组求逆序对](https://github.com/TANGoO666/Codeforces-Solutions/blob/main/%E5%85%B6%E4%BB%96%E9%A2%98%E8%A7%A3/%E6%B1%82%E6%8E%92%E5%88%97%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9.md)

感兴趣可以去看看
